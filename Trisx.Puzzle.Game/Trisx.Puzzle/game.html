<!doctype html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ปริศนาเชื่อมต่อท่อ</title>
  <!doctype html>
  <html lang="th">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>ปริศนาเชื่อมต่อท่อ (Pixel)</title>
    <style>
      /* Pixel-art aesthetic */
      @font-face{font-family:Pixel;src:local('Courier New');}
      :root{
        --bg:#071421; --panel:#0c2636; --accent:#00d4c4; --accent2:#ffd14d; --tile:#0a6b8a; --tile-acc:#12e6c9; --muted:#9fd6d0; --text:#e6fff8;
      }
      *{box-sizing:border-box}
      html,body{height:100%;}
      body{margin:0;background:linear-gradient(180deg,var(--bg),#071b2e);font-family:Pixel, 'Segoe UI', Roboto, monospace;color:var(--text);display:flex;align-items:center;justify-content:center;padding:18px}

      .container{width:900px;max-width:100%;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(0,0,0,0.06));border-radius:10px;padding:12px;display:grid;grid-template-columns:260px 1fr;gap:12px;border:3px solid rgba(255,255,255,0.03)}

      header{grid-column:1/-1;display:flex;align-items:center;justify-content:space-between}
      h1{margin:0;font-size:18px;letter-spacing:1px}

      .controls{display:flex;gap:8px;align-items:center}
      select,button{font-family:inherit;padding:6px 8px;border-radius:6px;border:2px solid rgba(255,255,255,0.06);background:linear-gradient(180deg,#0b3146,#05202a);color:var(--text);cursor:pointer}
      button.primary{background:linear-gradient(180deg,var(--accent2),var(--accent));color:#042027;border:none}

      .sidebar{background:linear-gradient(180deg,#062735,#042029);padding:10px;border-radius:8px;border:2px solid rgba(255,255,255,0.02)}
      .meta{display:flex;flex-direction:column;gap:8px}
      .small{font-size:13px;color:var(--muted)}

      /* Pixel board */
      .board-wrap{display:flex;flex-direction:column;align-items:center;gap:10px}
      .board{display:grid;background:#08242f;padding:8px;border-radius:8px;gap:6px;border:4px solid rgba(0,0,0,0.4)}

      .tile{image-rendering:pixelated;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,#073b4a,#05424b);border:3px solid rgba(0,0,0,0.6);width:80px;height:80px;border-radius:6px;cursor:pointer}
      .tile svg{width:90%;height:90%;shape-rendering:crispEdges}

      .footer{grid-column:1/-1;text-align:center;font-size:13px;color:var(--muted);padding-top:6px}

      @media(max-width:860px){.container{grid-template-columns:1fr}header{flex-direction:column;align-items:flex-start;gap:8px}}
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>ปริศนาเชื่อมต่อท่อ (Pixel)</h1>
        <div class="controls">
          <div class="small">ระดับ:</div>
          <select id="difficulty"><option value="3">3×3</option><option value="4" selected>4×4</option><option value="5">5×5</option></select>
          <button id="shuffleBtn" class="primary">สร้างใหม่</button>
          <button id="solveBtn">คำตอบ</button>
        </div>
      </header>

      <aside class="sidebar">
        <div class="meta">
          <div><strong>เวลา:</strong> <span id="timer">00:00</span></div>
          <div><strong>หมุน:</strong> <span id="moves">0</span></div>
          <div><strong>สถานะ:</strong> <span id="message" class="small">พร้อม</span></div>
          <hr />
          <div class="small">คลิกเพื่อหมุนท่อให้เชื่อมต่อ</div>
          <div style="display:flex;gap:6px;margin-top:6px"><button id="hintBtn">ช่วย</button><button id="resetBtn">รีเซ็ต</button></div>
        </div>
      </aside>

      <main class="board-wrap">
        <div id="board" class="board" role="application" aria-label="Puzzle board"></div>
      </main>

      <div class="footer">ออกแบบโดย SnoxkeR — Pixel edition</div>
    </div>

    <script>
    (function(){
      // Keep existing game logic; only change rendering to pixel look
      const boardEl = document.getElementById('board');
      const difficultyEl = document.getElementById('difficulty');
      const shuffleBtn = document.getElementById('shuffleBtn');
      const solveBtn = document.getElementById('solveBtn');
      const hintBtn = document.getElementById('hintBtn');
      const resetBtn = document.getElementById('resetBtn');
      const timerEl = document.getElementById('timer');
      const movesEl = document.getElementById('moves');
      const messageEl = document.getElementById('message');

      let size = Number(difficultyEl.value);
      let tiles = [];
      let solvedTiles = [];
      let moves = 0;
      let timer = null, startTime = null, elapsedBefore = 0;

      function idx(r,c){ return r*size + c; }
      function inside(r,c){ return r>=0 && c>=0 && r<size && c<size; }
      const dr = [-1,0,1,0];
      const dc = [0,1,0,-1];

      function formatTime(ms){ const s = Math.floor(ms/1000); const mm = String(Math.floor(s/60)).padStart(2,'0'); const ss = String(s%60).padStart(2,'0'); return mm+':'+ss; }
      function startTimer(){ if(timer) return; startTime = Date.now(); timer = setInterval(()=>{ timerEl.textContent = formatTime(Date.now() - startTime + elapsedBefore); }, 250); }
      function stopTimer(){ if(!timer) return; clearInterval(timer); timer=null; elapsedBefore += Date.now()-startTime; }
      function resetTimer(){ clearInterval(timer); timer=null; startTime=null; elapsedBefore=0; timerEl.textContent='00:00'; }

      function buildConnectedGraph(extra=0){
        const n=size*size; const visited=new Array(n).fill(false); const edges={}; for(let i=0;i<n;i++) edges[i]=new Set();
        const stack=[0]; visited[0]=true;
        while(stack.length){ const v=stack[stack.length-1]; const r=Math.floor(v/size), c=v%size; const neigh=[];
          for(let d=0;d<4;d++){ const nr=r+dr[d], nc=c+dc[d]; if(inside(nr,nc)){ const id=idx(nr,nc); if(!visited[id]) neigh.push(id); }}
          if(neigh.length===0){ stack.pop(); continue; }
          const to=neigh[Math.floor(Math.random()*neigh.length)]; edges[v].add(to); edges[to].add(v); visited[to]=true; stack.push(to);
        }
        const cand=[]; for(let r=0;r<size;r++) for(let c=0;c<size;c++){ const a=idx(r,c); for(let d=0;d<4;d++){ const nr=r+dr[d], nc=c+dc[d]; if(inside(nr,nc)){ const b=idx(nr,nc); if(!edges[a].has(b)) cand.push([a,b]); }}}
        for(let i=0;i<extra && cand.length;i++){ const j=Math.floor(Math.random()*cand.length); const [a,b]=cand.splice(j,1)[0]; edges[a].add(b); edges[b].add(a); }
        return edges;
      }

      function edgesToTileConnections(edges){ const n=size*size; const out=new Array(n); for(let r=0;r<size;r++) for(let c=0;c<size;c++){ const id=idx(r,c); const con=[false,false,false,false]; for(let d=0;d<4;d++){ const nr=r+dr[d], nc=c+dc[d]; if(inside(nr,nc)){ const nid=idx(nr,nc); if(edges[id].has(nid)) con[d]=true; }} out[id]=con; } return out; }

      function rotateArray(arr,rot){ const n=arr.length; const res=new Array(n); for(let i=0;i<n;i++) res[(i+rot)%n]=arr[i]; return res; }

      function generate(sz){ size = sz||Number(difficultyEl.value); const extra = Math.max(0,Math.floor(size/1.5)); const graph=buildConnectedGraph(extra); const base=edgesToTileConnections(graph);
        solvedTiles = base.map(b=>({base:b.slice(),rot:0})); tiles = solvedTiles.map(t=>({base:t.base.slice(), rot:Math.floor(Math.random()*4)})); if(isSolved()){ const k=Math.floor(Math.random()*tiles.length); tiles[k].rot=(tiles[k].rot+1)%4; }
        moves = 0; if(movesEl) movesEl.textContent = String(moves); resetTimer(); startTimer(); if(messageEl) messageEl.textContent='กำลังเล่น'; render(); }

      // Pixel-style renderer: use blocky rectangles instead of soft strokes
      function drawTileSVG(base,rot){
        const con = rotateArray(base,rot);
        const ns='http://www.w3.org/2000/svg';
        const svg=document.createElementNS(ns,'svg'); svg.setAttribute('viewBox','0 0 32 32'); svg.setAttribute('width','100%'); svg.setAttribute('height','100%');
        // background block (pixel feel)
        const bg = document.createElementNS(ns,'rect'); bg.setAttribute('x','0'); bg.setAttribute('y','0'); bg.setAttribute('width','32'); bg.setAttribute('height','32'); bg.setAttribute('fill','#082a35'); svg.appendChild(bg);
        // center pixel (4x4)
        const c = document.createElementNS(ns,'rect'); c.setAttribute('x','14'); c.setAttribute('y','14'); c.setAttribute('width','4'); c.setAttribute('height','4'); c.setAttribute('fill',getComputedStyle(document.documentElement).getPropertyValue('--accent')||'#00d4c4'); svg.appendChild(c);
        // branch helper draws a 4x12 rectangle in direction
        function branch(dx,dy){ const w = Math.abs(dx) ? 4 : 12; const h = Math.abs(dy) ? 4 : 12; const x = 14 + Math.min(0,dx); const y = 14 + Math.min(0,dy); const r=document.createElementNS(ns,'rect'); r.setAttribute('x',String(x)); r.setAttribute('y',String(y)); r.setAttribute('width',String(w)); r.setAttribute('height',String(h)); r.setAttribute('fill',getComputedStyle(document.documentElement).getPropertyValue('--accent2')||'#ffd14d'); svg.appendChild(r); }
        if(con[0]) branch(0,-12); if(con[1]) branch(12,0); if(con[2]) branch(0,12); if(con[3]) branch(-12,0);
        // add 1px black border pixels to emphasize pixel look
        const border = document.createElementNS(ns,'rect'); border.setAttribute('x','0'); border.setAttribute('y','0'); border.setAttribute('width','32'); border.setAttribute('height','32'); border.setAttribute('fill','none'); border.setAttribute('stroke','#001216'); border.setAttribute('stroke-width','1'); svg.appendChild(border);
        return svg;
      }

      function render(){ boardEl.innerHTML=''; boardEl.style.gridTemplateColumns = `repeat(${size}, 1fr)`; const max=Math.min(640,size*96); boardEl.style.width=max+'px'; boardEl.style.height=max+'px'; const tileSize=Math.floor(max/size)-6; tiles.forEach((t,id)=>{ const div=document.createElement('div'); div.className='tile'; div.style.width=tileSize+'px'; div.style.height=tileSize+'px'; div.dataset.id=id; div.appendChild(drawTileSVG(t.base,t.rot)); div.addEventListener('click',()=>{ rotateTile(id); }); boardEl.appendChild(div); }); }

      function rotateTile(id,amount=1){ tiles[id].rot=(tiles[id].rot+amount)%4; moves++; if(movesEl) movesEl.textContent=String(moves); render(); if(isSolved()){ stopTimer(); if(messageEl) messageEl.textContent='สำเร็จ!'; } }

      function isSolved(){ for(let r=0;r<size;r++) for(let c=0;c<size;c++){ const id=idx(r,c); const t=tiles[id]; const con=rotateArray(t.base,t.rot); for(let d=0;d<4;d++){ const nr=r+dr[d], nc=c+dc[d]; if(!inside(nr,nc)){ if(con[d]) return false; continue; } const nid=idx(nr,nc); const nt=tiles[nid]; const ncon=rotateArray(nt.base,nt.rot); const opp=(d+2)%4; if(con[d] !== ncon[opp]) return false; } } return true; }

      function arraysEqual(a,b){ if(a.length!==b.length) return false; for(let i=0;i<a.length;i++) if(a[i]!==b[i]) return false; return true; }

      hintBtn.addEventListener('click', ()=>{ const wrong=[]; for(let i=0;i<tiles.length;i++){ if(!arraysEqual(rotateArray(tiles[i].base,tiles[i].rot), rotateArray(solvedTiles[i].base,solvedTiles[i].rot))) wrong.push(i); } if(!wrong.length) return; const id=wrong[Math.floor(Math.random()*wrong.length)]; const orig=tiles[id].rot; tiles[id].rot=solvedTiles[id].rot; render(); setTimeout(()=>{ tiles[id].rot=orig; render(); },900); });
      resetBtn.addEventListener('click', ()=>{ generate(size); });
      shuffleBtn.addEventListener('click', ()=>{ generate(Number(difficultyEl.value)); });
      solveBtn.addEventListener('click', ()=>{ tiles=solvedTiles.map(t=>({base:t.base.slice(),rot:t.rot})); render(); stopTimer(); if(messageEl) messageEl.textContent='คำตอบ'; });
      difficultyEl.addEventListener('change', ()=>{ generate(Number(difficultyEl.value)); });

      // init
      generate(size);
    })();
    </script>
  </body>
  </html>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Trisx Puzzle — เชื่อมท่อ</title>
    <style>
      :root{
        --bg1:#071b2e; --bg2:#0b3b5a;
        --accent:#06b6d4; /* cyan */
        --accent2:#ff7ab6; /* pink */
        --tile1:#7c3aed; --tile2:#06b6d4; /* violet -> cyan */
        --text:#f8fafc; --muted:#cfeff6;
      }
      *{box-sizing:border-box}
    body{font-family:Segoe UI, Roboto, Arial;margin:0;min-height:100vh;background:linear-gradient(180deg,var(--bg1),var(--bg2));color:var(--text);display:flex;align-items:center;justify-content:center;padding:20px}
    .container{width:920px;max-width:100%;background:linear-gradient(135deg,rgba(255,255,255,0.03),rgba(0,0,0,0.08));box-shadow:0 8px 30px rgba(2,6,23,0.6);border-radius:12px;padding:18px;display:grid;grid-template-columns:300px 1fr;gap:16px}
      header{grid-column:1/-1;display:flex;align-items:center;justify-content:space-between}
      h1{font-size:20px;margin:0}
      .controls{display:flex;gap:8px;align-items:center}
      button,select{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--text);padding:8px 10px;border-radius:8px;cursor:pointer}
      button.primary{background:var(--accent);color:#042027;border:none}
      .sidebar{padding:8px;background:rgba(255,255,255,0.02);border-radius:8px}
      .board-wrap{display:flex;flex-direction:column;gap:12px;align-items:center;justify-content:center}
    .board{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(0,0,0,0.06));padding:12px;border-radius:10px;display:grid;gap:6px}
    .tile{background:linear-gradient(180deg,var(--tile1),var(--tile2));display:flex;align-items:center;justify-content:center;color:var(--text);border-radius:12px;user-select:none;cursor:pointer;transition:transform .18s;box-shadow:0 6px 18px rgba(2,6,23,0.45)}
      .tile svg{width:100%;height:100%}
      .meta{display:flex;flex-direction:column;gap:8px}
      .status{display:flex;gap:10px;align-items:center}
    .small{font-size:13px;color:var(--muted)}
    button.primary{background:linear-gradient(90deg,var(--accent),var(--accent2));color:#042027;border:none}
      .footer{grid-column:1/-1;text-align:center;font-size:13px;color:var(--muted);margin-top:6px}
      .instructions{font-size:13px;color:var(--muted);margin-top:8px}
      @media(max-width:840px){.container{grid-template-columns:1fr}header{flex-direction:column;align-items:flex-start;gap:8px}}
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>Trisx Puzzle — เกมเชื่อมท่อ</h1>
        <div class="controls">
          <div class="small">ระดับ:</div>
          <select id="difficulty">
            <option value="3">ง่าย (3×3)</option>
            <option value="4" selected>ปานกลาง (4×4)</option>
            <option value="5">ยาก (5×5)</option>
          </select>
          <button id="shuffleBtn" class="primary">สร้างใหม่ / สุ่ม</button>
          <button id="solveBtn">โชว์คำตอบ</button>
        </div>
      </header>

      <aside class="sidebar">
        <div class="meta">
          <div class="status"><strong>เวลา:</strong> <span id="timer">00:00</span></div>
          <div class="status"><strong>จำนวนการหมุน:</strong> <span id="moves">0</span></div>
          <div class="status"><strong>สถานะ:</strong> <span id="message" class="small">พร้อม</span></div>
          <hr />
          <div class="small">วิธีเล่น:</div>
          <div class="instructions">คลิกเพื่อหมุนทิศทางของท่อให้เชื่อมต่อกันทั้งหมด</div>
        </div>
      </aside>

      <main class="board-wrap">
        <div id="board" class="board" role="application" aria-label="Puzzle board"></div>
        <div style="display:flex;gap:8px"><button id="hintBtn">ช่วยเหลือ</button><button id="resetBtn">รีเซ็ต</button></div>
      </main>

      <div class="footer">ออกแบบโดย SnoxkeR — Trisx Puzzle</div>
    </div>

    <script>
      (function(){
        // Rotate & Connect — verbose UI
        const boardEl = document.getElementById('board');
        const difficultyEl = document.getElementById('difficulty');
        const shuffleBtn = document.getElementById('shuffleBtn');
        const solveBtn = document.getElementById('solveBtn');
        const hintBtn = document.getElementById('hintBtn');
        const resetBtn = document.getElementById('resetBtn');
        const timerEl = document.getElementById('timer');
        const movesEl = document.getElementById('moves');
        const messageEl = document.getElementById('message');

        let size = Number(difficultyEl.value);
        let tiles = [];
        let solvedTiles = [];
        let moves = 0;
        let timer = null, startTime = null, elapsedBefore = 0;

        function idx(r,c){ return r*size + c; }
        function inside(r,c){ return r>=0 && c>=0 && r<size && c<size; }
        const dr = [-1,0,1,0];
        const dc = [0,1,0,-1];

        function formatTime(ms){ const s = Math.floor(ms/1000); const mm = String(Math.floor(s/60)).padStart(2,'0'); const ss = String(s%60).padStart(2,'0'); return mm+':'+ss; }
        function startTimer(){ if(timer) return; startTime = Date.now(); timer = setInterval(()=>{ timerEl.textContent = formatTime(Date.now() - startTime + elapsedBefore); }, 250); }
        function stopTimer(){ if(!timer) return; clearInterval(timer); timer=null; elapsedBefore += Date.now()-startTime; }
        function resetTimer(){ clearInterval(timer); timer=null; startTime=null; elapsedBefore=0; timerEl.textContent='00:00'; }

        function buildConnectedGraph(extra=0){
          const n=size*size; const visited=new Array(n).fill(false); const edges={}; for(let i=0;i<n;i++) edges[i]=new Set();
          const stack=[0]; visited[0]=true;
          while(stack.length){ const v=stack[stack.length-1]; const r=Math.floor(v/size), c=v%size; const neigh=[];
            for(let d=0;d<4;d++){ const nr=r+dr[d], nc=c+dc[d]; if(inside(nr,nc)){ const id=idx(nr,nc); if(!visited[id]) neigh.push(id); }}
            if(neigh.length===0){ stack.pop(); continue; }
            const to=neigh[Math.floor(Math.random()*neigh.length)]; edges[v].add(to); edges[to].add(v); visited[to]=true; stack.push(to);
          }
          const cand=[]; for(let r=0;r<size;r++) for(let c=0;c<size;c++){ const a=idx(r,c); for(let d=0;d<4;d++){ const nr=r+dr[d], nc=c+dc[d]; if(inside(nr,nc)){ const b=idx(nr,nc); if(!edges[a].has(b)) cand.push([a,b]); }}}
          for(let i=0;i<extra && cand.length;i++){ const j=Math.floor(Math.random()*cand.length); const [a,b]=cand.splice(j,1)[0]; edges[a].add(b); edges[b].add(a); }
          return edges;
        }

        function edgesToTileConnections(edges){ const n=size*size; const out=new Array(n); for(let r=0;r<size;r++) for(let c=0;c<size;c++){ const id=idx(r,c); const con=[false,false,false,false]; for(let d=0;d<4;d++){ const nr=r+dr[d], nc=c+dc[d]; if(inside(nr,nc)){ const nid=idx(nr,nc); if(edges[id].has(nid)) con[d]=true; }} out[id]=con; } return out; }

        function rotateArray(arr,rot){ const n=arr.length; const res=new Array(n); for(let i=0;i<n;i++) res[(i+rot)%n]=arr[i]; return res; }

        function generate(sz){ size = sz||Number(difficultyEl.value); const extra = Math.max(0,Math.floor(size/1.5)); const graph=buildConnectedGraph(extra); const base=edgesToTileConnections(graph);
          solvedTiles = base.map(b=>({base:b.slice(),rot:0})); tiles = solvedTiles.map(t=>({base:t.base.slice(), rot:Math.floor(Math.random()*4)})); if(isSolved()){ const k=Math.floor(Math.random()*tiles.length); tiles[k].rot=(tiles[k].rot+1)%4; }
          moves = 0; if(movesEl) movesEl.textContent = String(moves); resetTimer(); startTimer(); if(messageEl) messageEl.textContent='กำลังเล่น'; render(); }

        function drawTileSVG(base,rot){
          const con=rotateArray(base,rot);
          const ns='http://www.w3.org/2000/svg';
          const svg=document.createElementNS(ns,'svg'); svg.setAttribute('viewBox','0 0 100 100');
          const center=document.createElementNS(ns,'circle'); center.setAttribute('cx','50'); center.setAttribute('cy','50'); center.setAttribute('r','10');
          // use computed style for dynamic colors
          const cs = getComputedStyle(document.documentElement);
          const fill = cs.getPropertyValue('--accent2') || '#0ccbd6';
          const stroke = cs.getPropertyValue('--accent') || '#77f0f6';
          center.setAttribute('fill', fill.trim()); svg.appendChild(center);
          function branch(x1,y1,x2,y2){ const p=document.createElementNS(ns,'path'); p.setAttribute('d',`M ${x1} ${y1} L ${x2} ${y2}`); p.setAttribute('stroke',stroke.trim()); p.setAttribute('stroke-width','14'); p.setAttribute('stroke-linecap','round'); svg.appendChild(p); }
          if(con[0]) branch(50,30,50,8); if(con[1]) branch(70,50,92,50); if(con[2]) branch(50,70,50,92); if(con[3]) branch(30,50,8,50);
          return svg;
        }

        function render(){ boardEl.innerHTML=''; boardEl.style.gridTemplateColumns = `repeat(${size}, 1fr)`; const max=Math.min(660,size*120); boardEl.style.width=max+'px'; boardEl.style.height=max+'px'; const tileSize=Math.floor(max/size)-6; tiles.forEach((t,id)=>{ const div=document.createElement('div'); div.className='tile'; div.style.width=tileSize+'px'; div.style.height=tileSize+'px'; div.dataset.id=id; div.appendChild(drawTileSVG(t.base,t.rot)); div.addEventListener('click',()=>{ rotateTile(id); }); boardEl.appendChild(div); }); }

        function rotateTile(id,amount=1){ tiles[id].rot=(tiles[id].rot+amount)%4; moves++; if(movesEl) movesEl.textContent=String(moves); render(); if(isSolved()){ stopTimer(); if(messageEl) messageEl.textContent='สำเร็จ!'; } }

        function isSolved(){ for(let r=0;r<size;r++) for(let c=0;c<size;c++){ const id=idx(r,c); const t=tiles[id]; const con=rotateArray(t.base,t.rot); for(let d=0;d<4;d++){ const nr=r+dr[d], nc=c+dc[d]; if(!inside(nr,nc)){ if(con[d]) return false; continue; } const nid=idx(nr,nc); const nt=tiles[nid]; const ncon=rotateArray(nt.base,nt.rot); const opp=(d+2)%4; if(con[d] !== ncon[opp]) return false; } } return true; }

        function arraysEqual(a,b){ if(a.length!==b.length) return false; for(let i=0;i<a.length;i++) if(a[i]!==b[i]) return false; return true; }

        hintBtn.addEventListener('click', ()=>{ const wrong=[]; for(let i=0;i<tiles.length;i++){ if(!arraysEqual(rotateArray(tiles[i].base,tiles[i].rot), rotateArray(solvedTiles[i].base,solvedTiles[i].rot))) wrong.push(i); } if(!wrong.length) return; const id=wrong[Math.floor(Math.random()*wrong.length)]; const orig=tiles[id].rot; tiles[id].rot=solvedTiles[id].rot; render(); setTimeout(()=>{ tiles[id].rot=orig; render(); },900); });
        resetBtn.addEventListener('click', ()=>{ generate(size); });
        shuffleBtn.addEventListener('click', ()=>{ generate(Number(difficultyEl.value)); });
        solveBtn.addEventListener('click', ()=>{ tiles=solvedTiles.map(t=>({base:t.base.slice(),rot:t.rot})); render(); stopTimer(); if(messageEl) messageEl.textContent='คำตอบ'; });
        difficultyEl.addEventListener('change', ()=>{ generate(Number(difficultyEl.value)); });

        // init
        generate(size);
      })();
    </script>
  </body>
  </html>
  <title>ปริศนาเชื่อมต่อท่อ</title>
  <style>
    :root{--bg:#071125;--card:#071d26;--accent:#06b6d4;--text:#e6eef6;--muted:#9fb6be}
    *{box-sizing:border-box}
    body{font-family:Segoe UI, Roboto, Arial;margin:0;min-height:100vh;background:linear-gradient(180deg,#04101b,#072033);color:var(--text);display:flex;align-items:center;justify-content:center;padding:20px}
    .container{width:920px;max-width:100%;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(0,0,0,0.12));border-radius:12px;padding:18px;display:grid;grid-template-columns:300px 1fr;gap:16px}
    header{grid-column:1/-1;display:flex;align-items:center;justify-content:space-between}
    h1{font-size:20px;margin:0}
    .controls{display:flex;gap:8px;align-items:center}
    button,select{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--text);padding:8px 10px;border-radius:8px;cursor:pointer}
    button.primary{background:var(--accent);color:#042027;border:none}
    .sidebar{padding:8px;background:rgba(255,255,255,0.02);border-radius:8px}
    .board-wrap{display:flex;flex-direction:column;gap:12px;align-items:center;justify-content:center}
    .board{background:#06202a;padding:12px;border-radius:10px;display:grid;gap:6px}
    .tile{background:linear-gradient(180deg,#0b3640,#06323a);display:flex;align-items:center;justify-content:center;color:#dff6f7;border-radius:8px;user-select:none;cursor:pointer;transition:transform .18s}
    .tile svg{width:100%;height:100%}
    .meta{display:flex;flex-direction:column;gap:8px}
    .status{display:flex;gap:10px;align-items:center}
    .small{font-size:13px;color:var(--muted)}
    .footer{grid-column:1/-1;text-align:center;font-size:13px;color:var(--muted);margin-top:6px}
    .instructions{font-size:13px;color:var(--muted);margin-top:8px}
    @media(max-width:840px){.container{grid-template-columns:1fr}header{flex-direction:column;align-items:flex-start;gap:8px}}
  </style>
</head>
<body>
  <div class="container">
    <header>
  <h1>ปริศนาเชื่อมต่อท่อ</h1>
      <div class="controls">
        <div class="small">ระดับ:</div>
        <select id="difficulty">
          <option value="3">ง่าย (3×3)</option>
          <option value="4" selected>ปานกลาง (4×4)</option>
          <option value="5">ยาก (5×5)</option>
        <!doctype html>
        <html lang="th">
        <head>
          <meta charset="utf-8" />
          <meta name="viewport" content="width=device-width,initial-scale=1" />
          <title>Trisx Puzzle — เชื่อมท่อ</title>
          <style>
            :root{
              --bg1:#071b2e; --bg2:#0b3b5a;
              --accent:#06b6d4; /* cyan */
              --accent2:#ff7ab6; /* pink */
              --tile1:#7c3aed; --tile2:#06b6d4; /* violet -> cyan */
              --text:#f8fafc; --muted:#cfeff6;
            }
            *{box-sizing:border-box}
            body{font-family:Segoe UI, Roboto, Arial;margin:0;min-height:100vh;background:linear-gradient(180deg,var(--bg1),var(--bg2));color:var(--text);display:flex;align-items:center;justify-content:center;padding:20px}
            .container{width:920px;max-width:100%;background:linear-gradient(135deg,rgba(255,255,255,0.03),rgba(0,0,0,0.08));box-shadow:0 8px 30px rgba(2,6,23,0.6);border-radius:12px;padding:18px;display:grid;grid-template-columns:300px 1fr;gap:16px}
            header{grid-column:1/-1;display:flex;align-items:center;justify-content:space-between}
            h1{font-size:20px;margin:0}
            .controls{display:flex;gap:8px;align-items:center}
            button,select{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--text);padding:8px 10px;border-radius:8px;cursor:pointer}
            button.primary{background:linear-gradient(90deg,var(--accent),var(--accent2));color:#042027;border:none}
            .sidebar{padding:8px;background:rgba(255,255,255,0.02);border-radius:8px}
            .board-wrap{display:flex;flex-direction:column;gap:12px;align-items:center;justify-content:center}
            .board{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(0,0,0,0.06));padding:12px;border-radius:10px;display:grid;gap:6px}
            .tile{background:linear-gradient(180deg,var(--tile1),var(--tile2));display:flex;align-items:center;justify-content:center;color:var(--text);border-radius:12px;user-select:none;cursor:pointer;transition:transform .18s;box-shadow:0 6px 18px rgba(2,6,23,0.45)}
            .tile svg{width:100%;height:100%}
            .meta{display:flex;flex-direction:column;gap:8px}
            .status{display:flex;gap:10px;align-items:center}
            .small{font-size:13px;color:var(--muted)}
            .footer{grid-column:1/-1;text-align:center;font-size:13px;color:var(--muted);margin-top:6px}
            .instructions{font-size:13px;color:var(--muted);margin-top:8px}
            @media(max-width:840px){.container{grid-template-columns:1fr}header{flex-direction:column;align-items:flex-start;gap:8px}}
          </style>
        </head>
        <body>
          <div class="container">
            <header>
        <h1>ปริศนาเชื่อมต่อท่อ</h1>
              <div class="controls">
                <div class="small">ระดับ:</div>
                <select id="difficulty">
                  <option value="3">ง่าย (3×3)</option>
                  <option value="4" selected>ปานกลาง (4×4)</option>
                  <option value="5">ยาก (5×5)</option>
                </select>
                <button id="shuffleBtn" class="primary">สร้างใหม่ / สุ่ม</button>
                <button id="solveBtn">โชว์คำตอบ</button>
              </div>
            </header>

            <aside class="sidebar">
              <div class="meta">
                <div class="status"><strong>เวลา:</strong> <span id="timer">00:00</span></div>
                <div class="status"><strong>จำนวนการหมุน:</strong> <span id="moves">0</span></div>
                <div class="status"><strong>สถานะ:</strong> <span id="message" class="small">พร้อม</span></div>
                <hr />
                <div class="small">วิธีเล่น:</div>
                <div class="instructions">คลิกเพื่อหมุนทิศทางของท่อให้เชื่อมต่อกันทั้งหมด</div>
              </div>
            </aside>

            <main class="board-wrap">
              <div id="board" class="board" role="application" aria-label="Puzzle board"></div>
              <div style="display:flex;gap:8px"><button id="hintBtn">ช่วยเหลือ</button><button id="resetBtn">รีเซ็ต</button></div>
            </main>

          <div class="footer">ออกแบบโดย SnoxkeR — ปริศนาเชื่อมต่อท่อ</div>
          </div>

          <script>
            (function(){
              // Rotate & Connect — verbose UI
              const boardEl = document.getElementById('board');
              const difficultyEl = document.getElementById('difficulty');
              const shuffleBtn = document.getElementById('shuffleBtn');
              const solveBtn = document.getElementById('solveBtn');
              const hintBtn = document.getElementById('hintBtn');
              const resetBtn = document.getElementById('resetBtn');
              const timerEl = document.getElementById('timer');
              const movesEl = document.getElementById('moves');
              const messageEl = document.getElementById('message');

              let size = Number(difficultyEl.value);
              let tiles = [];
              let solvedTiles = [];
              let moves = 0;
              let timer = null, startTime = null, elapsedBefore = 0;

              function idx(r,c){ return r*size + c; }
              function inside(r,c){ return r>=0 && c>=0 && r<size && c<size; }
              const dr = [-1,0,1,0];
              const dc = [0,1,0,-1];

              function formatTime(ms){ const s = Math.floor(ms/1000); const mm = String(Math.floor(s/60)).padStart(2,'0'); const ss = String(s%60).padStart(2,'0'); return mm+':'+ss; }
              function startTimer(){ if(timer) return; startTime = Date.now(); timer = setInterval(()=>{ timerEl.textContent = formatTime(Date.now() - startTime + elapsedBefore); }, 250); }
              function stopTimer(){ if(!timer) return; clearInterval(timer); timer=null; elapsedBefore += Date.now()-startTime; }
              function resetTimer(){ clearInterval(timer); timer=null; startTime=null; elapsedBefore=0; timerEl.textContent='00:00'; }

              function buildConnectedGraph(extra=0){
                const n=size*size; const visited=new Array(n).fill(false); const edges={}; for(let i=0;i<n;i++) edges[i]=new Set();
                const stack=[0]; visited[0]=true;
                while(stack.length){ const v=stack[stack.length-1]; const r=Math.floor(v/size), c=v%size; const neigh=[];
                  for(let d=0;d<4;d++){ const nr=r+dr[d], nc=c+dc[d]; if(inside(nr,nc)){ const id=idx(nr,nc); if(!visited[id]) neigh.push(id); }}
                  if(neigh.length===0){ stack.pop(); continue; }
                  const to=neigh[Math.floor(Math.random()*neigh.length)]; edges[v].add(to); edges[to].add(v); visited[to]=true; stack.push(to);
                }
                const cand=[]; for(let r=0;r<size;r++) for(let c=0;c<size;c++){ const a=idx(r,c); for(let d=0;d<4;d++){ const nr=r+dr[d], nc=c+dc[d]; if(inside(nr,nc)){ const b=idx(nr,nc); if(!edges[a].has(b)) cand.push([a,b]); }}}
                for(let i=0;i<extra && cand.length;i++){ const j=Math.floor(Math.random()*cand.length); const [a,b]=cand.splice(j,1)[0]; edges[a].add(b); edges[b].add(a); }
                return edges;
              }

              function edgesToTileConnections(edges){ const n=size*size; const out=new Array(n); for(let r=0;r<size;r++) for(let c=0;c<size;c++){ const id=idx(r,c); const con=[false,false,false,false]; for(let d=0;d<4;d++){ const nr=r+dr[d], nc=c+dc[d]; if(inside(nr,nc)){ const nid=idx(nr,nc); if(edges[id].has(nid)) con[d]=true; }} out[id]=con; } return out; }

              function rotateArray(arr,rot){ const n=arr.length; const res=new Array(n); for(let i=0;i<n;i++) res[(i+rot)%n]=arr[i]; return res; }

              function generate(sz){ size = sz||Number(difficultyEl.value); const extra = Math.max(0,Math.floor(size/1.5)); const graph=buildConnectedGraph(extra); const base=edgesToTileConnections(graph);
                solvedTiles = base.map(b=>({base:b.slice(),rot:0})); tiles = solvedTiles.map(t=>({base:t.base.slice(), rot:Math.floor(Math.random()*4)})); if(isSolved()){ const k=Math.floor(Math.random()*tiles.length); tiles[k].rot=(tiles[k].rot+1)%4; }
                moves = 0; if(movesEl) movesEl.textContent = String(moves); resetTimer(); startTimer(); if(messageEl) messageEl.textContent='กำลังเล่น'; render(); }

              function drawTileSVG(base,rot){
                const con=rotateArray(base,rot);
                const ns='http://www.w3.org/2000/svg';
                const svg=document.createElementNS(ns,'svg'); svg.setAttribute('viewBox','0 0 100 100');
                const center=document.createElementNS(ns,'circle'); center.setAttribute('cx','50'); center.setAttribute('cy','50'); center.setAttribute('r','10');
                const cs = getComputedStyle(document.documentElement);
                const fill = cs.getPropertyValue('--accent2') || '#0ccbd6';
                const stroke = cs.getPropertyValue('--accent') || '#77f0f6';
                center.setAttribute('fill', fill.trim()); svg.appendChild(center);
                function branch(x1,y1,x2,y2){ const p=document.createElementNS(ns,'path'); p.setAttribute('d',`M ${x1} ${y1} L ${x2} ${y2}`); p.setAttribute('stroke',stroke.trim()); p.setAttribute('stroke-width','14'); p.setAttribute('stroke-linecap','round'); svg.appendChild(p); }
                if(con[0]) branch(50,30,50,8); if(con[1]) branch(70,50,92,50); if(con[2]) branch(50,70,50,92); if(con[3]) branch(30,50,8,50);
                return svg;
              }

              function render(){ boardEl.innerHTML=''; boardEl.style.gridTemplateColumns = `repeat(${size}, 1fr)`; const max=Math.min(660,size*120); boardEl.style.width=max+'px'; boardEl.style.height=max+'px'; const tileSize=Math.floor(max/size)-6; tiles.forEach((t,id)=>{ const div=document.createElement('div'); div.className='tile'; div.style.width=tileSize+'px'; div.style.height=tileSize+'px'; div.dataset.id=id; div.appendChild(drawTileSVG(t.base,t.rot)); div.addEventListener('click',()=>{ rotateTile(id); }); boardEl.appendChild(div); }); }

              function rotateTile(id,amount=1){ tiles[id].rot=(tiles[id].rot+amount)%4; moves++; if(movesEl) movesEl.textContent=String(moves); render(); if(isSolved()){ stopTimer(); if(messageEl) messageEl.textContent='สำเร็จ!'; } }

              function isSolved(){ for(let r=0;r<size;r++) for(let c=0;c<size;c++){ const id=idx(r,c); const t=tiles[id]; const con=rotateArray(t.base,t.rot); for(let d=0;d<4;d++){ const nr=r+dr[d], nc=c+dc[d]; if(!inside(nr,nc)){ if(con[d]) return false; continue; } const nid=idx(nr,nc); const nt=tiles[nid]; const ncon=rotateArray(nt.base,nt.rot); const opp=(d+2)%4; if(con[d] !== ncon[opp]) return false; } } return true; }

              function arraysEqual(a,b){ if(a.length!==b.length) return false; for(let i=0;i<a.length;i++) if(a[i]!==b[i]) return false; return true; }

              hintBtn.addEventListener('click', ()=>{ const wrong=[]; for(let i=0;i<tiles.length;i++){ if(!arraysEqual(rotateArray(tiles[i].base,tiles[i].rot), rotateArray(solvedTiles[i].base,solvedTiles[i].rot))) wrong.push(i); } if(!wrong.length) return; const id=wrong[Math.floor(Math.random()*wrong.length)]; const orig=tiles[id].rot; tiles[id].rot=solvedTiles[id].rot; render(); setTimeout(()=>{ tiles[id].rot=orig; render(); },900); });
              resetBtn.addEventListener('click', ()=>{ generate(size); });
              shuffleBtn.addEventListener('click', ()=>{ generate(Number(difficultyEl.value)); });
              solveBtn.addEventListener('click', ()=>{ tiles=solvedTiles.map(t=>({base:t.base.slice(),rot:t.rot})); render(); stopTimer(); if(messageEl) messageEl.textContent='คำตอบ'; });
              difficultyEl.addEventListener('change', ()=>{ generate(Number(difficultyEl.value)); });

              // init
              generate(size);
            })();
          </script>
        </body>
        </html>
          <h1>Trisx Puzzle — เกมเชื่อมท่อ</h1>
          <div class="controls">
            <div class="small">ระดับ:</div>
            <select id="difficulty">
              <option value="3">ง่าย (3×3)</option>
              <option value="4" selected>ปานกลาง (4×4)</option>
              <option value="5">ยาก (5×5)</option>
            </select>
            <button id="shuffleBtn" class="primary">สร้างใหม่ / สุ่ม</button>
            <button id="solveBtn">โชว์คำตอบ</button>
          </div>
        </header>

        <aside class="sidebar">
          <div class="meta">
            <div class="status"><strong>เวลา:</strong> <span id="timer">00:00</span></div>
            <div class="status"><strong>จำนวนการหมุน:</strong> <span id="moves">0</span></div>
            <div class="status"><strong>สถานะ:</strong> <span id="message" class="small">พร้อม</span></div>
            <hr />
            <div class="small">วิธีเล่น:</div>
            <div class="instructions">คลิกเพื่อหมุนทิศทางของท่อให้เชื่อมต่อกันทั้งหมด</div>
          </div>
        </aside>

        <main class="board-wrap">
          <div id="board" class="board" role="application" aria-label="Puzzle board"></div>
          <div style="display:flex;gap:8px"><button id="hintBtn">ช่วยเหลือ</button><button id="resetBtn">รีเซ็ต</button></div>
        </main>

    <div class="footer">ออกแบบโดย SnoxkeR — ปริศนาเชื่อมต่อท่อ</div>
      </div>

      <script>
        (function(){
          // Restore verbose Rotate & Connect implementation
          const boardEl = document.getElementById('board');
          const difficultyEl = document.getElementById('difficulty');
          const shuffleBtn = document.getElementById('shuffleBtn');
          const solveBtn = document.getElementById('solveBtn');
          const hintBtn = document.getElementById('hintBtn');
          const resetBtn = document.getElementById('resetBtn');
          const timerEl = document.getElementById('timer');
          const movesEl = document.getElementById('moves');
          const messageEl = document.getElementById('message');

          let size = Number(difficultyEl.value);
          let tiles = [];
          let solvedTiles = [];
          let moves = 0;
          let timer = null, startTime = null, elapsedBefore = 0;

          function idx(r,c){ return r*size + c; }
          function inside(r,c){ return r>=0 && c>=0 && r<size && c<size; }
          const dr = [-1,0,1,0];
          const dc = [0,1,0,-1];

          function formatTime(ms){ const s = Math.floor(ms/1000); const mm = String(Math.floor(s/60)).padStart(2,'0'); const ss = String(s%60).padStart(2,'0'); return mm+':'+ss; }
          function startTimer(){ if(timer) return; startTime = Date.now(); timer = setInterval(()=>{ timerEl.textContent = formatTime(Date.now() - startTime + elapsedBefore); }, 250); }
          function stopTimer(){ if(!timer) return; clearInterval(timer); timer=null; elapsedBefore += Date.now()-startTime; }
          function resetTimer(){ clearInterval(timer); timer=null; startTime=null; elapsedBefore=0; timerEl.textContent='00:00'; }

          function buildConnectedGraph(extra=0){
            const n=size*size; const visited=new Array(n).fill(false); const edges={}; for(let i=0;i<n;i++) edges[i]=new Set();
            const stack=[0]; visited[0]=true;
            while(stack.length){ const v=stack[stack.length-1]; const r=Math.floor(v/size), c=v%size; const neigh=[];
              for(let d=0;d<4;d++){ const nr=r+dr[d], nc=c+dc[d]; if(inside(nr,nc)){ const id=idx(nr,nc); if(!visited[id]) neigh.push(id); }}
              if(neigh.length===0){ stack.pop(); continue; }
              const to=neigh[Math.floor(Math.random()*neigh.length)]; edges[v].add(to); edges[to].add(v); visited[to]=true; stack.push(to);
            }
            const cand=[]; for(let r=0;r<size;r++) for(let c=0;c<size;c++){ const a=idx(r,c); for(let d=0;d<4;d++){ const nr=r+dr[d], nc=c+dc[d]; if(inside(nr,nc)){ const b=idx(nr,nc); if(!edges[a].has(b)) cand.push([a,b]); }}}
            for(let i=0;i<extra && cand.length;i++){ const j=Math.floor(Math.random()*cand.length); const [a,b]=cand.splice(j,1)[0]; edges[a].add(b); edges[b].add(a); }
            return edges;
          }

          function edgesToTileConnections(edges){ const n=size*size; const out=new Array(n); for(let r=0;r<size;r++) for(let c=0;c<size;c++){ const id=idx(r,c); const con=[false,false,false,false]; for(let d=0;d<4;d++){ const nr=r+dr[d], nc=c+dc[d]; if(inside(nr,nc)){ const nid=idx(nr,nc); if(edges[id].has(nid)) con[d]=true; }} out[id]=con; } return out; }

          function rotateArray(arr,rot){ const n=arr.length; const res=new Array(n); for(let i=0;i<n;i++) res[(i+rot)%n]=arr[i]; return res; }

          function generate(sz){ size = sz||Number(difficultyEl.value); const extra = Math.max(0,Math.floor(size/1.5)); const graph=buildConnectedGraph(extra); const base=edgesToTileConnections(graph);
            solvedTiles = base.map(b=>({base:b.slice(),rot:0})); tiles = solvedTiles.map(t=>({base:t.base.slice(), rot:Math.floor(Math.random()*4)})); if(isSolved()){ const k=Math.floor(Math.random()*tiles.length); tiles[k].rot=(tiles[k].rot+1)%4; }
            moves = 0; if(movesEl) movesEl.textContent = String(moves); resetTimer(); startTimer(); if(messageEl) messageEl.textContent='กำลังเล่น'; render(); }

          function drawTileSVG(base,rot){ const con=rotateArray(base,rot); const ns='http://www.w3.org/2000/svg'; const svg=document.createElementNS(ns,'svg'); svg.setAttribute('viewBox','0 0 100 100'); const center=document.createElementNS(ns,'circle'); center.setAttribute('cx','50'); center.setAttribute('cy','50'); center.setAttribute('r','10'); center.setAttribute('fill','#0ccbd6'); svg.appendChild(center); function branch(x1,y1,x2,y2){ const p=document.createElementNS(ns,'path'); p.setAttribute('d',`M ${x1} ${y1} L ${x2} ${y2}`); p.setAttribute('stroke','#77f0f6'); p.setAttribute('stroke-width','14'); p.setAttribute('stroke-linecap','round'); svg.appendChild(p); } if(con[0]) branch(50,30,50,8); if(con[1]) branch(70,50,92,50); if(con[2]) branch(50,70,50,92); if(con[3]) branch(30,50,8,50); return svg; }

          function render(){ boardEl.innerHTML=''; boardEl.style.gridTemplateColumns = `repeat(${size}, 1fr)`; const max=Math.min(660,size*120); boardEl.style.width=max+'px'; boardEl.style.height=max+'px'; const tileSize=Math.floor(max/size)-6; tiles.forEach((t,id)=>{ const div=document.createElement('div'); div.className='tile'; div.style.width=tileSize+'px'; div.style.height=tileSize+'px'; div.dataset.id=id; div.appendChild(drawTileSVG(t.base,t.rot)); div.addEventListener('click',()=>{ rotateTile(id); }); boardEl.appendChild(div); }); }

          function rotateTile(id,amount=1){ tiles[id].rot=(tiles[id].rot+amount)%4; moves++; if(movesEl) movesEl.textContent=String(moves); render(); if(isSolved()){ stopTimer(); if(messageEl) messageEl.textContent='สำเร็จ!'; } }

          function isSolved(){ for(let r=0;r<size;r++) for(let c=0;c<size;c++){ const id=idx(r,c); const t=tiles[id]; const con=rotateArray(t.base,t.rot); for(let d=0;d<4;d++){ const nr=r+dr[d], nc=c+dc[d]; if(!inside(nr,nc)){ if(con[d]) return false; continue; } const nid=idx(nr,nc); const nt=tiles[nid]; const ncon=rotateArray(nt.base,nt.rot); const opp=(d+2)%4; if(con[d] !== ncon[opp]) return false; } } return true; }

          function arraysEqual(a,b){ if(a.length!==b.length) return false; for(let i=0;i<a.length;i++) if(a[i]!==b[i]) return false; return true; }

          hintBtn.addEventListener('click', ()=>{ const wrong=[]; for(let i=0;i<tiles.length;i++){ if(!arraysEqual(rotateArray(tiles[i].base,tiles[i].rot), rotateArray(solvedTiles[i].base,solvedTiles[i].rot))) wrong.push(i); } if(!wrong.length) return; const id=wrong[Math.floor(Math.random()*wrong.length)]; const orig=tiles[id].rot; tiles[id].rot=solvedTiles[id].rot; render(); setTimeout(()=>{ tiles[id].rot=orig; render(); },900); });
          resetBtn.addEventListener('click', ()=>{ generate(size); });
          shuffleBtn.addEventListener('click', ()=>{ generate(Number(difficultyEl.value)); });
          solveBtn.addEventListener('click', ()=>{ tiles=solvedTiles.map(t=>({base:t.base.slice(),rot:t.rot})); render(); stopTimer(); if(messageEl) messageEl.textContent='คำตอบ'; });
          difficultyEl.addEventListener('change', ()=>{ generate(Number(difficultyEl.value)); });

          // init
          generate(size);
        })();
      </script>
    </body>
    </html>
+    </aside>
+
            <main class="board-wrap">
+      <div id="board" class="board" role="application" aria-label="Puzzle board"></div>
+      <div style="display:flex;gap:8px"><button id="hintBtn">ช่วยเหลือ</button><button id="resetBtn">รีเซ็ต</button></div>
+    </main>
+
+
+    <div class="footer">ออกแบบโดย SnoxkeR — Trisx Puzzle</div>
+  </div>
+
+  <script>
// Rotate & Connect puzzle
// Contract:
// Inputs: difficulty (3/4/5), clicks to rotate tiles
// Outputs: board state, moves, timer, solved detection
// Plan: build a connected graph (spanning tree + optional extra edges), encode each tile's connections, then randomly rotate each tile from solved state to create a solvable puzzle.